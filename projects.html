
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>李博文的个人作品集</title>
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
</head>
<body>
<canvas id="matrix-canvas"></canvas>

<div id="particles-js"></div>

    <header>
        <div class="logo">李博文</div>
        <nav>
            <ul>
                <li><a href="index.html">首页</a></li>
                <li><a href="about.html">关于我</a></li>
                <li><a href="projects.html">项目展示</a></li>
                <li><a href="video.html">视频演示</a></li>
                <li><a href="contact.html">联系我</a></li>
            </ul>
        </nav>
    </header>

    <section class="section projects">
        <h2>项目展示</h2>

        <div class="section-content">
            <h3>基于三维点云的手术器械识别</h3>
            <p>根据客户要求总结了一个基于三维点云的手术器械识别方案，用算法对3D点云数据做合理的分割，将手术器械部分点云和箱体部分点云分割后，去除箱体部分。</p>
            <p>基于统计滤波的思想对离群噪点进行合理剔除，以提高点云的质量。对目标点云和模板点云进行全局粗配准和细配准，得到两者之间的变换矩阵或对应关系，根据输出的参数确定型号。</p>
            <p>通过匹配点对的个数、变换矩阵、配准拟合度分数、匹配/差异点的个数，并输出点云可视化图、匹配对应点可视化图、差异点可视化图。但是这个方案由于点云计算耗时较慢而没被弃置。</p>
            <p>改用基于YoloV5框架的深度学习识别点云深度图的方案，解决了上述的难点。该项目我也负责了所有3D建模的mesh图绘制工作，学习并在实际项目中有针对性地使用了泊松Poisson重建算法和Ball Pivoting重建算法，对不同几何特征的物体做三维重建。</p>
            <div class="images">
                <img src="images/project1_img1.png" alt="三维点云手术器械识别 图1" class="image">
                <img src="images/project1_img2.png" alt="三维点云手术器械识别 图2" class="image">
                <img src="images/project1_img3.png" alt="三维点云手术器械识别 图3" class="image">
            </div>
        </div>

        <div class="section-content">
            <h3>高光谱深度学习模型开发</h3>
            <p>负责调研适合高光谱深度学习的模型，根据理解编写基于FCNN的模型并训练了大量数据，并基于Python和C++都做了分割演示。</p>
            <p>基于实时性分析的需求有针对性地学习了Onnx和TensorRT相关内容，掌握了C++的深度学习高性能部署，利用GPU的高速并行计算能力充分满足实时性。</p>
            <p>实时推理帧率从原本的0.3FPS提高到了实时的30FPS，达到了实时性能要求。并配合将深度学习算法封装移植到软件里。十月初深度学习算法开发基本已经结束，我继续参与到机器学习算法移植的开发中。</p>
            <p>我将基于XGBoost和LightGBM的机器学习算法库通过CMake的方式编译为C++可以使用的dll，自学有关C++机器学习算法部署的知识，成功开发了高光谱机器学习算法预测回归的功能，并且在这个过程中也写出了Savitsky-Golay滤波算法、一阶差分算法等预处理，满足了客户的要求。</p>
            <p>在这个过程中我熟练掌握了OpenCV的核心库，使用但不限于包括矩阵运算、放大缩小、颜色映射、归一化等操作。后面我也成功将这些算法封装成函数移植到了软件中。该项目顺利验收。</p>
            <div class="images">
                <img src="images/project2_img1.png" alt="高光谱深度学习模型 图1" class="image">
                <img src="images/project2_img2.png" alt="高光谱深度学习模型 图2" class="image">
                <img src="images/project2_img3.png" alt="高光谱深度学习模型 图3" class="image">
            </div>
        </div>

        <div class="section-content">
            <h3>基于ZIVID TWO+ M60相机的二次开发上位机操作软件</h3>
            <p>基于ZIVID TWO+ M60相机编写了一个二次开发的上位机操作软件，采用QT5框架，可以控制相机进行手动拍照，也可以基于TCP通讯指令进行自动拍照，然后基于HTTP协议将拍摄得到的数据文件上传到对应的算法服务器。</p>
            <p>本人独立完成了全部软件的开发。该软件可以手动调整相机参数进行拍照测试，也可以作为TCP服务器接受客户端的连接，根据收到的指令解析出触发命令的关键词，并进行相应的参数调整、拍照、上传等动作。</p>
            <p>该软件还可以记录所有操作的日志详情，并支持一键导出本地，便于后续的错误分析。</p>
            <div class="images">
                <img src="images/project3_img1.png" alt="ZIVID TWO+ M60相机软件开发 图1" class="image">
            </div>
        </div>
    </section>

    <footer>
        <p>© 2024 李博文. 版权所有.</p>
    </footer>

<script>
particlesJS("particles-js", {
    "particles": {
        "number": {
            "value": 80,
            "density": {
                "enable": true,
                "value_area": 800
            }
        },
        "color": {
            "value": "#ffffff"
        },
        "shape": {
            "type": "circle",
            "stroke": {
                "width": 0,
                "color": "#000000"
            },
            "polygon": {
                "nb_sides": 5
            }
        },
        "opacity": {
            "value": 0.5,
            "random": false,
            "anim": {
                "enable": false,
                "speed": 1,
                "opacity_min": 0.1,
                "sync": false
            }
        },
        "size": {
            "value": 3,
            "random": true,
            "anim": {
                "enable": false,
                "speed": 40,
                "size_min": 0.1,
                "sync": false
            }
        },
        "line_linked": {
            "enable": true,
            "distance": 150,
            "color": "#ffffff",
            "opacity": 0.4,
            "width": 1
        },
        "move": {
            "enable": true,
            "speed": 6,
            "direction": "none",
            "random": false,
            "straight": false,
            "out_mode": "out",
            "bounce": false,
            "attract": {
                "enable": false,
                "rotateX": 600,
                "rotateY": 1200
            }
        }
    },
    "interactivity": {
        "detect_on": "canvas",
        "events": {
            "onhover": {
                "enable": true,
                "mode": "grab"
            },
            "onclick": {
                "enable": true,
                "mode": "push"
            },
            "resize": true
        },
        "modes": {
            "grab": {
                "distance": 140,
                "line_linked": {
                    "opacity": 1
                }
            },
            "bubble": {
                "distance": 400,
                "size": 40,
                "duration": 2,
                "opacity": 8,
                "speed": 3
            },
            "repulse": {
                "distance": 200,
                "duration": 0.4
            },
            "push": {
                "particles_nb": 4
            },
            "remove": {
                "particles_nb": 2
            }
        }
    },
    "retina_detect": true
});
</script>

<script>
const canvas = document.getElementById('matrix-canvas');
const ctx = canvas.getContext('2d');

// Set canvas full screen
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Characters to display
const characters = '01';
const fontSize = 16;
const columns = canvas.width / fontSize;
const drops = Array(Math.floor(columns)).fill(0);

function draw() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#00ff00';
    ctx.font = `${fontSize}px monospace`;

    for (let i = 0; i < drops.length; i++) {
        const text = characters[Math.floor(Math.random() * characters.length)];
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
            drops[i] = 0;
        }

        drops[i]++;
    }
}

setInterval(draw, 33);
</script>
</body>

</html>
